{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factorySpace } from 'micromark-factory-space';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\n/** @type {Construct} */\n\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n};\n/** @type {Construct} */\n\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this;\n  /** @type {string} */\n\n  let identifier;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition');\n    return factoryLabel.call(self, effects, labelAfter, nok, 'definitionLabel', 'definitionLabelMarker', 'definitionLabelString')(code);\n  }\n  /** @type {State} */\n\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));\n\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker'); // Note: blank lines can’t exist in content.\n\n      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, 'whitespace'), factorySpace(effects, after, 'whitespace')), nok, 'definitionDestination', 'definitionDestinationLiteral', 'definitionDestinationLiteralMarker', 'definitionDestinationRaw', 'definitionDestinationString'));\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition');\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier);\n      }\n\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before)(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(effects, factorySpace(effects, after, 'whitespace'), nok, 'definitionTitle', 'definitionTitleMarker', 'definitionTitleString')(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/micromark-core-commonmark/lib/definition.js"],"names":["factoryDestination","factoryLabel","factorySpace","factoryTitle","factoryWhitespace","normalizeIdentifier","markdownLineEnding","markdownLineEndingOrSpace","definition","name","tokenize","tokenizeDefinition","titleConstruct","tokenizeTitle","partial","effects","ok","nok","self","identifier","start","code","enter","call","labelAfter","sliceSerialize","events","length","slice","consume","exit","attempt","after","parser","defined","includes","push","before"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\n/** @type {Construct} */\n\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n\n  let identifier\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Note: blank lines can’t exist in content.\n\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, 'whitespace'),\n            factorySpace(effects, after, 'whitespace')\n          ),\n          nok,\n          'definitionDestination',\n          'definitionDestinationLiteral',\n          'definitionDestinationLiteralMarker',\n          'definitionDestinationRaw',\n          'definitionDestinationString'\n        )\n      )\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, 'whitespace'),\n        nok,\n        'definitionTitle',\n        'definitionTitleMarker',\n        'definitionTitleString'\n      )(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}