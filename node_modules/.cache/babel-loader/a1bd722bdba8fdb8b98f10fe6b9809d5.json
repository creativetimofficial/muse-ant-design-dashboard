{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} Options\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n *\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\n */\nimport { toHast } from 'mdast-util-to-hast'; // Note: the `<MdastRoot, HastRoot>` overload doesn’t seem to work :'(\n\n/**\n * Plugin to bridge or mutate to rehype.\n *\n * If a destination is given, runs the destination with the new hast tree\n * (bridge-mode).\n * Without destination, returns the hast tree: further plugins run on that tree\n * (mutate-mode).\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `mdast-util-to-hast`.\n */\n\nconst remarkRehype = function (destination, options) {\n  return destination && 'run' in destination ? bridge(destination, options) : mutate(destination);\n};\n\nexport default remarkRehype;\n/**\n * Bridge-mode.\n * Runs the destination with the new hast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\n */\n\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toHast(node, options), file, error => {\n      next(error);\n    });\n  };\n}\n/**\n * Mutate-mode.\n * Further transformers run on the nlcst tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\n */\n\n\nfunction mutate(options) {\n  // @ts-expect-error: assume a corresponding node is returned for `toHast`.\n  return node => toHast(node, options);\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/remark-rehype/index.js"],"names":["toHast","remarkRehype","destination","options","bridge","mutate","node","file","next","run","error"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,MAAR,QAAqB,oBAArB,C,CAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,YAAY,GAGd,UAAUC,WAAV,EAAuBC,OAAvB,EAAgC;AAC9B,SAAOD,WAAW,IAAI,SAASA,WAAxB,GACHE,MAAM,CAACF,WAAD,EAAcC,OAAd,CADH,GAEHE,MAAM,CAACH,WAAD,CAFV;AAGD,CAPL;;AAUA,eAAeD,YAAf;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASG,MAAT,CAAgBF,WAAhB,EAA6BC,OAA7B,EAAsC;AACpC,SAAO,CAACG,IAAD,EAAOC,IAAP,EAAaC,IAAb,KAAsB;AAC3BN,IAAAA,WAAW,CAACO,GAAZ,CAAgBT,MAAM,CAACM,IAAD,EAAOH,OAAP,CAAtB,EAAuCI,IAAvC,EAA8CG,KAAD,IAAW;AACtDF,MAAAA,IAAI,CAACE,KAAD,CAAJ;AACD,KAFD;AAGD,GAJD;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASL,MAAT,CAAgBF,OAAhB,EAAyB;AACvB;AACA,SAAQG,IAAD,IAAUN,MAAM,CAACM,IAAD,EAAOH,OAAP,CAAvB;AACD","sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} Options\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n *\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n// Note: the `<MdastRoot, HastRoot>` overload doesn’t seem to work :'(\n\n/**\n * Plugin to bridge or mutate to rehype.\n *\n * If a destination is given, runs the destination with the new hast tree\n * (bridge-mode).\n * Without destination, returns the hast tree: further plugins run on that tree\n * (mutate-mode).\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `mdast-util-to-hast`.\n */\nconst remarkRehype =\n  /** @type {(import('unified').Plugin<[Processor, Options?]|[Options]|[], MdastRoot>)} */\n  (\n    function (destination, options) {\n      return destination && 'run' in destination\n        ? bridge(destination, options)\n        : mutate(destination)\n    }\n  )\n\nexport default remarkRehype\n\n/**\n * Bridge-mode.\n * Runs the destination with the new hast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toHast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further transformers run on the nlcst tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\n */\nfunction mutate(options) {\n  // @ts-expect-error: assume a corresponding node is returned for `toHast`.\n  return (node) => toHast(node, options)\n}\n"]},"metadata":{},"sourceType":"module"}