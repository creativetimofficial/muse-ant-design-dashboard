{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').State} State\n */\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\n/**\n * @this {TokenizeContext}\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\n\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this;\n  let size = 0;\n  /** @type {boolean} */\n\n  let data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    effects.enter(stringType);\n    return atBreak;\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    if (code === null || code === 91 || code === 93 && !data || code === 94 && !size && '_hiddenFootnoteSupport' in self.parser.constructs || size > 999) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      effects.exit(stringType);\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return atBreak;\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === null || code === 91 || code === 93 || markdownLineEnding(code) || size++ > 999) {\n      effects.exit('chunkString');\n      return atBreak(code);\n    }\n\n    effects.consume(code);\n    data = data || !markdownSpace(code);\n    return code === 92 ? labelEscape : label;\n  }\n  /** @type {State} */\n\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n\n    return label(code);\n  }\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/micromark-factory-label/index.js"],"names":["markdownLineEnding","markdownSpace","factoryLabel","effects","ok","nok","type","markerType","stringType","self","size","data","start","code","enter","consume","exit","atBreak","parser","constructs","contentType","label","labelEscape"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\n/**\n * @this {TokenizeContext}\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this\n  let size = 0\n  /** @type {boolean} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      (code === 93 && !data) ||\n      /* Hidden footnotes hook */\n\n      /* c8 ignore next 3 */\n      (code === 94 &&\n        !size &&\n        '_hiddenFootnoteSupport' in self.parser.constructs) ||\n      size > 999\n    ) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return atBreak\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return label(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      code === 93 ||\n      markdownLineEnding(code) ||\n      size++ > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    data = data || !markdownSpace(code)\n    return code === 92 ? labelEscape : label\n  }\n  /** @type {State} */\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}