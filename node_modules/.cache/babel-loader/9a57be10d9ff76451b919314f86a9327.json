{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\nimport { splice } from 'micromark-util-chunked';\nconst hasOwnProperty = {}.hasOwnProperty;\n/**\n * Combine several syntax extensions into one.\n *\n * @param {Extension[]} extensions List of syntax extensions.\n * @returns {NormalizedExtension} A single combined extension.\n */\n\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {};\n  let index = -1;\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index]);\n  }\n\n  return all;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all Extension to merge into.\n * @param {Extension} extension Extension to merge.\n * @returns {void}\n */\n\nfunction syntaxExtension(all, extension) {\n  /** @type {string} */\n  let hook;\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n    const left = maybe || (all[hook] = {});\n    const right = extension[hook];\n    /** @type {string} */\n\n    let code;\n\n    for (code in right) {\n      if (!hasOwnProperty.call(left, code)) left[code] = [];\n      const value = right[code];\n      constructs( // @ts-expect-error Looks like a list.\n      left[code], Array.isArray(value) ? value : value ? [value] : []);\n    }\n  }\n}\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {unknown[]} existing\n * @param {unknown[]} list\n * @returns {void}\n */\n\n\nfunction constructs(existing, list) {\n  let index = -1;\n  /** @type {unknown[]} */\n\n  const before = [];\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;\n    (list[index].add === 'after' ? existing : before).push(list[index]);\n  }\n\n  splice(existing, 0, 0, before);\n}\n/**\n * Combine several HTML extensions into one.\n *\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\n * @returns {HtmlExtension} A single combined extension.\n */\n\n\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {};\n  let index = -1;\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index]);\n  }\n\n  return handlers;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all Extension to merge into.\n * @param {HtmlExtension} extension Extension to merge.\n * @returns {void}\n */\n\nfunction htmlExtension(all, extension) {\n  /** @type {string} */\n  let hook;\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n    const left = maybe || (all[hook] = {});\n    const right = extension[hook];\n    /** @type {string} */\n\n    let type;\n\n    if (right) {\n      for (type in right) {\n        left[type] = right[type];\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/micromark-util-combine-extensions/index.js"],"names":["splice","hasOwnProperty","combineExtensions","extensions","all","index","length","syntaxExtension","extension","hook","maybe","call","undefined","left","right","code","value","constructs","Array","isArray","existing","list","before","add","push","combineHtmlExtensions","htmlExtensions","handlers","htmlExtension","type"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine several syntax extensions into one.\n *\n * @param {Extension[]} extensions List of syntax extensions.\n * @returns {NormalizedExtension} A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all Extension to merge into.\n * @param {Extension} extension Extension to merge.\n * @returns {void}\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {string} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    for (code in right) {\n      if (!hasOwnProperty.call(left, code)) left[code] = []\n      const value = right[code]\n      constructs(\n        // @ts-expect-error Looks like a list.\n        left[code],\n        Array.isArray(value) ? value : value ? [value] : []\n      )\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {unknown[]} existing\n * @param {unknown[]} list\n * @returns {void}\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {unknown[]} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine several HTML extensions into one.\n *\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\n * @returns {HtmlExtension} A single combined extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all Extension to merge into.\n * @param {HtmlExtension} extension Extension to merge.\n * @returns {void}\n */\nfunction htmlExtension(all, extension) {\n  /** @type {string} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {string} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        left[type] = right[type]\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}