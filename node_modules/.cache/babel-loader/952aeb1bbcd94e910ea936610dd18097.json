{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownSpace } from 'micromark-util-character';\n/** @type {Construct} */\n\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState;\n\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        });\n        state.open = true;\n      }\n\n      effects.enter('blockQuotePrefix');\n      effects.enter('blockQuoteMarker');\n      effects.consume(code);\n      effects.exit('blockQuoteMarker');\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace');\n      effects.consume(code);\n      effects.exit('blockQuotePrefixWhitespace');\n      effects.exit('blockQuotePrefix');\n      return ok;\n    }\n\n    effects.exit('blockQuotePrefix');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(effects, effects.attempt(blockQuote, ok, nok), 'linePrefix', this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n}\n/** @type {Exiter} */\n\n\nfunction exit(effects) {\n  effects.exit('blockQuote');\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/micromark-core-commonmark/lib/block-quote.js"],"names":["factorySpace","markdownSpace","blockQuote","name","tokenize","tokenizeBlockQuoteStart","continuation","tokenizeBlockQuoteContinuation","exit","effects","ok","nok","self","start","code","state","containerState","open","enter","_container","consume","after","attempt","parser","constructs","disable","null","includes","undefined"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,YAAR,QAA2B,yBAA3B;AACA,SAAQC,aAAR,QAA4B,0BAA5B;AAEA;;AACA,OAAO,MAAMC,UAAU,GAAG;AACxBC,EAAAA,IAAI,EAAE,YADkB;AAExBC,EAAAA,QAAQ,EAAEC,uBAFc;AAGxBC,EAAAA,YAAY,EAAE;AACZF,IAAAA,QAAQ,EAAEG;AADE,GAHU;AAMxBC,EAAAA;AANwB,CAAnB;AAQP;;AAEA,SAASH,uBAAT,CAAiCI,OAAjC,EAA0CC,EAA1C,EAA8CC,GAA9C,EAAmD;AACjD,QAAMC,IAAI,GAAG,IAAb;AACA,SAAOC,KAAP;AACA;;AAEA,WAASA,KAAT,CAAeC,IAAf,EAAqB;AACnB,QAAIA,IAAI,KAAK,EAAb,EAAiB;AACf,YAAMC,KAAK,GAAGH,IAAI,CAACI,cAAnB;;AAEA,UAAI,CAACD,KAAK,CAACE,IAAX,EAAiB;AACfR,QAAAA,OAAO,CAACS,KAAR,CAAc,YAAd,EAA4B;AAC1BC,UAAAA,UAAU,EAAE;AADc,SAA5B;AAGAJ,QAAAA,KAAK,CAACE,IAAN,GAAa,IAAb;AACD;;AAEDR,MAAAA,OAAO,CAACS,KAAR,CAAc,kBAAd;AACAT,MAAAA,OAAO,CAACS,KAAR,CAAc,kBAAd;AACAT,MAAAA,OAAO,CAACW,OAAR,CAAgBN,IAAhB;AACAL,MAAAA,OAAO,CAACD,IAAR,CAAa,kBAAb;AACA,aAAOa,KAAP;AACD;;AAED,WAAOV,GAAG,CAACG,IAAD,CAAV;AACD;AACD;;;AAEA,WAASO,KAAT,CAAeP,IAAf,EAAqB;AACnB,QAAIb,aAAa,CAACa,IAAD,CAAjB,EAAyB;AACvBL,MAAAA,OAAO,CAACS,KAAR,CAAc,4BAAd;AACAT,MAAAA,OAAO,CAACW,OAAR,CAAgBN,IAAhB;AACAL,MAAAA,OAAO,CAACD,IAAR,CAAa,4BAAb;AACAC,MAAAA,OAAO,CAACD,IAAR,CAAa,kBAAb;AACA,aAAOE,EAAP;AACD;;AAEDD,IAAAA,OAAO,CAACD,IAAR,CAAa,kBAAb;AACA,WAAOE,EAAE,CAACI,IAAD,CAAT;AACD;AACF;AACD;;;AAEA,SAASP,8BAAT,CAAwCE,OAAxC,EAAiDC,EAAjD,EAAqDC,GAArD,EAA0D;AACxD,SAAOX,YAAY,CACjBS,OADiB,EAEjBA,OAAO,CAACa,OAAR,CAAgBpB,UAAhB,EAA4BQ,EAA5B,EAAgCC,GAAhC,CAFiB,EAGjB,YAHiB,EAIjB,KAAKY,MAAL,CAAYC,UAAZ,CAAuBC,OAAvB,CAA+BC,IAA/B,CAAoCC,QAApC,CAA6C,cAA7C,IAA+DC,SAA/D,GAA2E,CAJ1D,CAAnB;AAMD;AACD;;;AAEA,SAASpB,IAAT,CAAcC,OAAd,EAAuB;AACrBA,EAAAA,OAAO,CAACD,IAAR,CAAa,YAAb;AACD","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState\n\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        state.open = true\n      }\n\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(blockQuote, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n/** @type {Exiter} */\n\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n"]},"metadata":{},"sourceType":"module"}