{"ast":null,"code":"/**\n * @typedef {import('mdast').Root|import('mdast').Parent['children'][number]} MdastNode\n * @typedef {import('./index.js').H} H\n * @typedef {import('./index.js').Handler} Handler\n * @typedef {import('./index.js').Content} Content\n */\nimport { u } from 'unist-builder';\nconst own = {}.hasOwnProperty;\n/**\n * Transform an unknown node.\n * @type {Handler}\n * @param {MdastNode} node\n */\n\nfunction unknown(h, node) {\n  const data = node.data || {};\n\n  if ('value' in node && !(own.call(data, 'hName') || own.call(data, 'hProperties') || own.call(data, 'hChildren'))) {\n    return h.augment(node, u('text', node.value));\n  }\n\n  return h(node, 'div', all(h, node));\n}\n/**\n * @type {Handler}\n * @param {MdastNode} node\n */\n\n\nexport function one(h, node, parent) {\n  const type = node && node.type;\n  /** @type {Handler} */\n\n  let fn; // Fail on non-nodes.\n\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n\n  if (own.call(h.handlers, type)) {\n    fn = h.handlers[type];\n  } else if (h.passThrough && h.passThrough.includes(type)) {\n    fn = returnNode;\n  } else {\n    fn = h.unknownHandler;\n  }\n\n  return (typeof fn === 'function' ? fn : unknown)(h, node, parent);\n}\n/**\n * @type {Handler}\n * @param {MdastNode} node\n */\n\nfunction returnNode(h, node) {\n  // @ts-expect-error: Pass through custom node.\n  return 'children' in node ? { ...node,\n    children: all(h, node)\n  } : node;\n}\n/**\n * @param {H} h\n * @param {MdastNode} parent\n */\n\n\nexport function all(h, parent) {\n  /** @type {Array.<Content>} */\n  const values = [];\n\n  if ('children' in parent) {\n    const nodes = parent.children;\n    let index = -1;\n\n    while (++index < nodes.length) {\n      const result = one(h, nodes[index], parent);\n\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '');\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0];\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '');\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result);\n        } else {\n          values.push(result);\n        }\n      }\n    }\n  }\n\n  return values;\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/mdast-util-to-hast/lib/traverse.js"],"names":["u","own","hasOwnProperty","unknown","h","node","data","call","augment","value","all","one","parent","type","fn","Error","handlers","passThrough","includes","returnNode","unknownHandler","children","values","nodes","index","length","result","Array","isArray","replace","head","push"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('mdast').Root|import('mdast').Parent['children'][number]} MdastNode\n * @typedef {import('./index.js').H} H\n * @typedef {import('./index.js').Handler} Handler\n * @typedef {import('./index.js').Content} Content\n */\n\nimport {u} from 'unist-builder'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Transform an unknown node.\n * @type {Handler}\n * @param {MdastNode} node\n */\nfunction unknown(h, node) {\n  const data = node.data || {}\n\n  if (\n    'value' in node &&\n    !(\n      own.call(data, 'hName') ||\n      own.call(data, 'hProperties') ||\n      own.call(data, 'hChildren')\n    )\n  ) {\n    return h.augment(node, u('text', node.value))\n  }\n\n  return h(node, 'div', all(h, node))\n}\n\n/**\n * @type {Handler}\n * @param {MdastNode} node\n */\nexport function one(h, node, parent) {\n  const type = node && node.type\n  /** @type {Handler} */\n  let fn\n\n  // Fail on non-nodes.\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n\n  if (own.call(h.handlers, type)) {\n    fn = h.handlers[type]\n  } else if (h.passThrough && h.passThrough.includes(type)) {\n    fn = returnNode\n  } else {\n    fn = h.unknownHandler\n  }\n\n  return (typeof fn === 'function' ? fn : unknown)(h, node, parent)\n}\n\n/**\n * @type {Handler}\n * @param {MdastNode} node\n */\nfunction returnNode(h, node) {\n  // @ts-expect-error: Pass through custom node.\n  return 'children' in node ? {...node, children: all(h, node)} : node\n}\n\n/**\n * @param {H} h\n * @param {MdastNode} parent\n */\nexport function all(h, parent) {\n  /** @type {Array.<Content>} */\n  const values = []\n\n  if ('children' in parent) {\n    const nodes = parent.children\n    let index = -1\n\n    while (++index < nodes.length) {\n      const result = one(h, nodes[index], parent)\n\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '')\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0]\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '')\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result)\n        } else {\n          values.push(result)\n        }\n      }\n    }\n  }\n\n  return values\n}\n"]},"metadata":{},"sourceType":"module"}