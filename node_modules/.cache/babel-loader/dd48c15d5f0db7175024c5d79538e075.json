{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\n/** @type {Construct} */\n\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this;\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  };\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  };\n  const tail = this.events[this.events.length - 1];\n  const initialPrefix = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n\n  let marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced');\n    effects.enter('codeFencedFence');\n    effects.enter('codeFencedFenceSequence');\n    marker = code;\n    return sequenceOpen(code);\n  }\n  /** @type {State} */\n\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n\n    effects.exit('codeFencedFenceSequence');\n    return sizeOpen < 3 ? nok(code) : factorySpace(effects, infoOpen, 'whitespace')(code);\n  }\n  /** @type {State} */\n\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('codeFencedFenceInfo');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return info(code);\n  }\n  /** @type {State} */\n\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString');\n      effects.exit('codeFencedFenceInfo');\n      return factorySpace(effects, infoAfter, 'whitespace')(code);\n    }\n\n    if (code === 96 && code === marker) return nok(code);\n    effects.consume(code);\n    return info;\n  }\n  /** @type {State} */\n\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('codeFencedFenceMeta');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return meta(code);\n  }\n  /** @type {State} */\n\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString');\n      effects.exit('codeFencedFenceMeta');\n      return openAfter(code);\n    }\n\n    if (code === 96 && code === marker) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n  /** @type {State} */\n\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence');\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n  /** @type {State} */\n\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, 'linePrefix', initialPrefix + 1) : contentStart), after)(code);\n    }\n\n    effects.enter('codeFlowValue');\n    return contentContinue(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue');\n      return contentStart(code);\n    }\n\n    effects.consume(code);\n    return contentContinue;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('codeFenced');\n    return ok(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return lineStart;\n    }\n    /** @type {State} */\n\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    return factorySpace(effects, closingSequenceStart, 'linePrefix', this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence');\n      effects.enter('codeFencedFenceSequence');\n      return closingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n\n      if (size < sizeOpen) return nok(code);\n      effects.exit('codeFencedFenceSequence');\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence');\n        return ok(code);\n      }\n\n      return nok(code);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/micromark-core-commonmark/lib/code-fenced.js"],"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","codeFenced","name","tokenize","tokenizeCodeFenced","concrete","effects","ok","nok","self","closingFenceConstruct","tokenizeClosingFence","partial","nonLazyLine","tokenizeNonLazyLine","tail","events","length","initialPrefix","type","sliceSerialize","sizeOpen","marker","start","code","enter","sequenceOpen","consume","exit","infoOpen","openAfter","contentType","info","infoAfter","meta","interrupt","contentStart","after","attempt","contentContinue","lineStart","parser","lazy","now","line","size","closingSequenceStart","constructs","disable","null","includes","undefined","closingSequence","closingSequenceEnd"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  }\n  const tail = this.events[this.events.length - 1]\n  const initialPrefix =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    marker = code\n    return sequenceOpen(code)\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('codeFencedFenceSequence')\n    return sizeOpen < 3\n      ? nok(code)\n      : factorySpace(effects, infoOpen, 'whitespace')(code)\n  }\n  /** @type {State} */\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n  /** @type {State} */\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, infoAfter, 'whitespace')(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n  /** @type {State} */\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          closingFenceConstruct,\n          after,\n          initialPrefix\n            ? factorySpace(\n                effects,\n                contentStart,\n                'linePrefix',\n                initialPrefix + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return contentContinue(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      'linePrefix',\n      this.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence')\n      effects.enter('codeFencedFenceSequence')\n      return closingSequence(code)\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('codeFencedFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}