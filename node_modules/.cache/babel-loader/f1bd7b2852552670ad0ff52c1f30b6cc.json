{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiDigit, markdownSpace } from 'micromark-util-character';\nimport { blankLine } from './blank-line.js';\nimport { thematicBreak } from './thematic-break.js';\n/** @type {Construct} */\n\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n};\n/** @type {Construct} */\n\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n};\n/** @type {Construct} */\n\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  let initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? 'listUnordered' : 'listOrdered');\n\n    if (kind === 'listUnordered' ? !self.containerState.marker || code === self.containerState.marker : asciiDigit(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, {\n          _container: true\n        });\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix');\n        return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix');\n        effects.enter('listItemValue');\n        return inside(code);\n      }\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code);\n      return inside;\n    }\n\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n      effects.exit('listItemValue');\n      return atMarker(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * @type {State}\n   **/\n\n\n  function atMarker(code) {\n    effects.enter('listItemMarker');\n    effects.consume(code);\n    effects.exit('listItemMarker');\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(blankLine, // Can’t be empty when interrupting.\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n  }\n  /** @type {State} */\n\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n  /** @type {State} */\n\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace');\n      effects.consume(code);\n      effects.exit('listItemPrefixWhitespace');\n      return endOfPrefix;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit('listItemPrefix'), true).length;\n    return ok(code);\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(blankLine, onBlank, notBlank);\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine; // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return factorySpace(effects, ok, 'listItemIndent', self.containerState.size + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined;\n      self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n\n    self.containerState.furtherBlankLines = undefined;\n    self.containerState.initialBlankLine = undefined;\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n  }\n  /** @type {State} */\n\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true; // As we’re closing flow, we’re no longer interrupting.\n\n    self.interrupt = undefined;\n    return factorySpace(effects, effects.attempt(list, ok, nok), 'linePrefix', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, 'listItemIndent', self.containerState.size + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'listItemIndent' && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\n  }\n}\n/**\n * @type {Exiter}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, 'listItemPrefixWhitespace', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4 + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return !markdownSpace(code) && tail && tail[1].type === 'listItemPrefixWhitespace' ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/micromark-core-commonmark/lib/list.js"],"names":["factorySpace","asciiDigit","markdownSpace","blankLine","thematicBreak","list","name","tokenize","tokenizeListStart","continuation","tokenizeListContinuation","exit","tokenizeListEnd","listItemPrefixWhitespaceConstruct","tokenizeListItemPrefixWhitespace","partial","indentConstruct","tokenizeIndent","effects","ok","nok","self","tail","events","length","initialSize","type","sliceSerialize","size","start","code","kind","containerState","marker","enter","_container","check","atMarker","interrupt","inside","consume","onBlank","attempt","endOfPrefix","otherPrefix","initialBlankLine","_closeFlow","undefined","notBlank","furtherBlankLines","notInCurrentItem","parser","constructs","disable","null","includes","afterPrefix"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n/** @type {Construct} */\n\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n/** @type {Construct} */\n\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n/** @type {Construct} */\n\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n\n    return nok(code)\n  }\n  /**\n   * @type {State}\n   **/\n\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine, // Can’t be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n  /** @type {State} */\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n  /** @type {State} */\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n  /** @type {State} */\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true // As we’re closing flow, we’re no longer interrupting.\n\n    self.interrupt = undefined\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n/**\n * @type {Exiter}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}