{"ast":null,"code":"/**\n * @typedef {(error?: Error|null|undefined, ...output: any[]) => void} Callback\n * @typedef {(...input: any[]) => any} Middleware\n *\n * @typedef {(...input: any[]) => void} Run Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nexport function trough() {\n  /** @type {Middleware[]} */\n  const fns = [];\n  /** @type {Pipeline} */\n\n  const pipeline = {\n    run,\n    use\n  };\n  return pipeline;\n  /** @type {Run} */\n\n  function run(...values) {\n    let middlewareIndex = -1;\n    /** @type {Callback} */\n\n    const callback = values.pop();\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback);\n    }\n\n    next(null, ...values);\n    /**\n     * Run the next `fn`, or we’re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {any[]} output\n     */\n\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex];\n      let index = -1;\n\n      if (error) {\n        callback(error);\n        return;\n      } // Copy non-nullish input into values.\n\n\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index];\n        }\n      } // Save the newly created `output` for the next call.\n\n\n      values = output; // Next or done.\n\n      if (fn) {\n        wrap(fn, next)(...output);\n      } else {\n        callback(null, ...output);\n      }\n    }\n  }\n  /** @type {Use} */\n\n\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError('Expected `middelware` to be a function, not ' + middelware);\n    }\n\n    fns.push(middelware);\n    return pipeline;\n  }\n}\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\n\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called;\n  return wrapped;\n  /**\n   * Call `middleware`.\n   * @param {any[]} parameters\n   * @returns {void}\n   */\n\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length;\n    /** @type {any} */\n\n    let result;\n\n    if (fnExpectsCallback) {\n      parameters.push(done);\n    }\n\n    try {\n      result = middleware(...parameters);\n    } catch (error) {\n      /** @type {Error} */\n      const exception = error; // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n\n      if (fnExpectsCallback && called) {\n        throw exception;\n      }\n\n      return done(exception);\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done);\n      } else if (result instanceof Error) {\n        done(result);\n      } else {\n        then(result);\n      }\n    }\n  }\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n\n\n  function done(error, ...output) {\n    if (!called) {\n      called = true;\n      callback(error, ...output);\n    }\n  }\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n\n\n  function then(value) {\n    done(null, value);\n  }\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/trough/index.js"],"names":["trough","fns","pipeline","run","use","values","middlewareIndex","callback","pop","TypeError","next","error","output","fn","index","length","undefined","wrap","middelware","push","middleware","called","wrapped","parameters","fnExpectsCallback","result","done","exception","Promise","then","Error","value"],"mappings":"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","sourcesContent":["/**\n * @typedef {(error?: Error|null|undefined, ...output: any[]) => void} Callback\n * @typedef {(...input: any[]) => any} Middleware\n *\n * @typedef {(...input: any[]) => void} Run Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nexport function trough() {\n  /** @type {Middleware[]} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or we’re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {any[]} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @param {any[]} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware(...parameters)\n    } catch (error) {\n      /** @type {Error} */\n      const exception = error\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}