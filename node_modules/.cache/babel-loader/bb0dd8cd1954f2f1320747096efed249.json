{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/** @type {Construct} */\n\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\n\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n};\n/** @type {Construct} */\n\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n};\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  /** @type {Token} */\n\n  let token;\n\n  while (++index < events.length) {\n    token = events[index][1];\n\n    if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);\n      token.type = 'data';\n      index++;\n    }\n  }\n\n  return events;\n}\n/** @type {Resolver} */\n\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n\n  let token;\n  /** @type {number|undefined} */\n\n  let open;\n  /** @type {number|undefined} */\n\n  let close;\n  /** @type {Event[]} */\n\n  let media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {\n        open = index;\n\n        if (token.type !== 'labelLink') {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index;\n    }\n  }\n\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  media = push(media, [['enter', text, context]]); // Between.\n\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)); // Media close.\n\n  media = push(media, [['exit', group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n\n  let labelStart;\n  /** @type {boolean} */\n\n  let defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code);\n    } // It’s a balanced bracket, but contains a link.\n\n\n    if (labelStart._inactive) return balanced(code);\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter('labelEnd');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelEnd');\n    return afterLabelEnd;\n  }\n  /** @type {State} */\n\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n\n    if (code === 91) {\n      return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);\n    } // Shortcut reference: `[asd]`?\n\n\n    return defined ? ok(code) : balanced(code);\n  }\n  /** @type {State} */\n\n\n  function balanced(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource');\n    effects.enter('resourceMarker');\n    effects.consume(code);\n    effects.exit('resourceMarker');\n    return factoryWhitespace(effects, open);\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 41) {\n      return end(code);\n    }\n\n    return factoryDestination(effects, destinationAfter, nok, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 3)(code);\n  }\n  /** @type {State} */\n\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, between)(code) : end(code);\n  }\n  /** @type {State} */\n\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(effects, factoryWhitespace(effects, end), nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker');\n      effects.consume(code);\n      effects.exit('resourceMarker');\n      effects.exit('resource');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return factoryLabel.call(self, effects, afterLabel, nok, 'reference', 'referenceMarker', 'referenceString')(code);\n  }\n  /** @type {State} */\n\n\n  function afterLabel(code) {\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference');\n    effects.enter('referenceMarker');\n    effects.consume(code);\n    effects.exit('referenceMarker');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker');\n      effects.consume(code);\n      effects.exit('referenceMarker');\n      effects.exit('reference');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/micromark-core-commonmark/lib/label-end.js"],"names":["factoryDestination","factoryLabel","factoryTitle","factoryWhitespace","markdownLineEndingOrSpace","push","splice","normalizeIdentifier","resolveAll","labelEnd","name","tokenize","tokenizeLabelEnd","resolveTo","resolveToLabelEnd","resolveAllLabelEnd","resourceConstruct","tokenizeResource","fullReferenceConstruct","tokenizeFullReference","collapsedReferenceConstruct","tokenizeCollapsedReference","events","index","token","length","type","context","offset","open","close","media","_inactive","_balanced","group","start","Object","assign","end","label","text","slice","parser","constructs","insideSpan","null","effects","ok","nok","self","labelStart","defined","code","balanced","includes","sliceSerialize","now","enter","consume","exit","afterLabelEnd","attempt","destinationAfter","between","call","afterLabel"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\n\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n}\n/** @type {Construct} */\n\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n}\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Token} */\n\n  let token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n\n  return events\n}\n/** @type {Resolver} */\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n\n  let token\n  /** @type {number|undefined} */\n\n  let open\n  /** @type {number|undefined} */\n\n  let close\n  /** @type {Event[]} */\n\n  let media // Find an opening.\n\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ] // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)) // Text open.\n\n  media = push(media, [['enter', text, context]]) // Between.\n\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  ) // Text close, marker close, label close.\n\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ]) // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)) // Media close.\n\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n\n  let labelStart\n  /** @type {boolean} */\n\n  let defined // Find an opening.\n\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code)\n    } // It’s a balanced bracket, but contains a link.\n\n    if (labelStart._inactive) return balanced(code)\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return afterLabelEnd\n  }\n  /** @type {State} */\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n    if (code === 91) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    } // Shortcut reference: `[asd]`?\n\n    return defined ? ok(code) : balanced(code)\n  }\n  /** @type {State} */\n\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return factoryWhitespace(effects, open)\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 41) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      3\n    )(code)\n  }\n  /** @type {State} */\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n  /** @type {State} */\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function afterLabel(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}