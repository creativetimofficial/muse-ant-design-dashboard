{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Resolver[]} */\n  const called = [];\n  let index = -1;\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll;\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context);\n      called.push(resolve);\n    }\n  }\n\n  return events;\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/micromark-util-resolve-all/index.js"],"names":["resolveAll","constructs","events","context","called","index","length","resolve","includes","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,UAAT,CAAoBC,UAApB,EAAgCC,MAAhC,EAAwCC,OAAxC,EAAiD;AACtD;AACA,QAAMC,MAAM,GAAG,EAAf;AACA,MAAIC,KAAK,GAAG,CAAC,CAAb;;AAEA,SAAO,EAAEA,KAAF,GAAUJ,UAAU,CAACK,MAA5B,EAAoC;AAClC,UAAMC,OAAO,GAAGN,UAAU,CAACI,KAAD,CAAV,CAAkBL,UAAlC;;AAEA,QAAIO,OAAO,IAAI,CAACH,MAAM,CAACI,QAAP,CAAgBD,OAAhB,CAAhB,EAA0C;AACxCL,MAAAA,MAAM,GAAGK,OAAO,CAACL,MAAD,EAASC,OAAT,CAAhB;AACAC,MAAAA,MAAM,CAACK,IAAP,CAAYF,OAAZ;AACD;AACF;;AAED,SAAOL,MAAP;AACD","sourcesContent":["/**\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Resolver[]} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n"]},"metadata":{},"sourceType":"module"}