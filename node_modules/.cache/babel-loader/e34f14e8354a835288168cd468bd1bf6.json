{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {UnistParent & {type: 'fragment', children: PhrasingContent[]}} Fragment\n */\n\n/**\n * @typedef _CompileDataFields\n * @property {boolean|undefined} expectingFirstListItemValue\n * @property {boolean|undefined} flowCodeInside\n * @property {boolean|undefined} setextHeadingSlurpLineEnding\n * @property {boolean|undefined} atHardBreak\n * @property {'collapsed'|'full'} referenceType\n * @property {boolean|undefined} inReference\n * @property {'characterReferenceMarkerHexadecimal'|'characterReferenceMarkerNumeric'} characterReferenceType\n *\n * @typedef {Record<string, unknown> & Partial<_CompileDataFields>} CompileData\n *\n * @typedef {(tree: Root) => Root|void} Transform\n * @typedef {(this: CompileContext, token: Token) => void} Handle\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n * @typedef {Record<string, Record<string, unknown>|Array.<unknown>> & {canContainEols: Array.<string>, transforms: Array.<Transform>, enter: Handles, exit: Handles}} NormalizedExtension\n * @typedef {Partial<NormalizedExtension>} Extension\n *   An mdast extension changes how markdown tokens are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context\n * @property {Array.<Node | Fragment>} stack\n * @property {Array.<Token>} tokenStack\n * @property {(key: string, value?: unknown) => void} setData\n *   Set data into the key-value store.\n * @property {<K extends string>(key: K) => CompileData[K]} getData\n *   Get data from the key-value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<N extends Node>(this: CompileContext, node: N, token: Token) => N} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {NormalizedExtension} config\n *   Configuration.\n *\n * @typedef {{mdastExtensions?: Array.<Extension|Array.<Extension>>}} FromMarkdownOptions\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n */\nimport { toString } from 'mdast-util-to-string';\nimport { parse } from 'micromark/lib/parse.js';\nimport { preprocess } from 'micromark/lib/preprocess.js';\nimport { postprocess } from 'micromark/lib/postprocess.js';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { decodeString } from 'micromark-util-decode-string';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { decodeEntity } from 'parse-entities/decode-entity.js';\nimport { stringifyPosition } from 'unist-util-stringify-position';\nconst own = {}.hasOwnProperty;\n/**\n * @param value Markdown to parse (`string` or `Buffer`).\n * @param [encoding] Character encoding to understand `value` as when it’s a `Buffer` (`string`, default: `'utf8'`).\n * @param [options] Configuration\n */\n\nexport const fromMarkdown =\n/**\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {Options} [options]\n * @returns {Root}\n */\nfunction (value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options} [options]\n */\n\nfunction compiler(options = {}) {\n  /** @type {NormalizedExtension} */\n  // @ts-expect-error: our base has all required fields, so the result will too.\n  const config = configure({\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }, options.mdastExtensions || []);\n  /** @type {CompileData} */\n\n  const data = {};\n  return compile;\n  /**\n   * @param {Array.<Event>} events\n   * @returns {Root}\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {CompileContext['stack']} */\n\n    const stack = [tree];\n    /** @type {CompileContext['tokenStack']} */\n\n    const tokenStack = [];\n    /** @type {Array.<number>} */\n\n    const listStack = [];\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    const context = {\n      stack,\n      tokenStack,\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    };\n    let index = -1;\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === 'listOrdered' || events[index][1].type === 'listUnordered') {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          const tail = listStack.pop();\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n\n    index = -1;\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]];\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    }\n\n    if (tokenStack.length > 0) {\n      throw new Error('Cannot close document, a token (`' + tokenStack[tokenStack.length - 1].type + '`, ' + stringifyPosition({\n        start: tokenStack[tokenStack.length - 1].start,\n        end: tokenStack[tokenStack.length - 1].end\n      }) + ') is still open');\n    } // Figure out `root` position.\n\n\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    };\n    index = -1;\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n\n    return tree;\n  }\n  /**\n   * @param {Array.<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n\n  function prepareList(events, start, length) {\n    let index = start - 1;\n    let containerBalance = -1;\n    let listSpread = false;\n    /** @type {Token|undefined} */\n\n    let listItem;\n    /** @type {number|undefined} */\n\n    let lineIndex;\n    /** @type {number|undefined} */\n\n    let firstBlankLineIndex;\n    /** @type {boolean|undefined} */\n\n    let atMarker;\n\n    while (++index <= length) {\n      const event = events[index];\n\n      if (event[1].type === 'listUnordered' || event[1].type === 'listOrdered' || event[1].type === 'blockQuote') {\n        if (event[0] === 'enter') {\n          containerBalance++;\n        } else {\n          containerBalance--;\n        }\n\n        atMarker = undefined;\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n            firstBlankLineIndex = index;\n          }\n\n          atMarker = undefined;\n        }\n      } else if (event[1].type === 'linePrefix' || event[1].type === 'listItemValue' || event[1].type === 'listItemMarker' || event[1].type === 'listItemPrefix' || event[1].type === 'listItemPrefixWhitespace') {// Empty.\n      } else {\n        atMarker = undefined;\n      }\n\n      if (!containerBalance && event[0] === 'enter' && event[1].type === 'listItemPrefix' || containerBalance === -1 && event[0] === 'exit' && (event[1].type === 'listUnordered' || event[1].type === 'listOrdered')) {\n        if (listItem) {\n          let tailIndex = index;\n          lineIndex = undefined;\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex];\n\n            if (tailEvent[1].type === 'lineEnding' || tailEvent[1].type === 'lineEndingBlank') {\n              if (tailEvent[0] === 'exit') continue;\n\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank';\n                listSpread = true;\n              }\n\n              tailEvent[1].type = 'lineEnding';\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === 'linePrefix' || tailEvent[1].type === 'blockQuotePrefix' || tailEvent[1].type === 'blockQuotePrefixWhitespace' || tailEvent[1].type === 'blockQuoteMarker' || tailEvent[1].type === 'listItemIndent') {// Empty\n            } else {\n              break;\n            }\n          }\n\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            // @ts-expect-error Patched.\n            listItem._spread = true;\n          } // Fix position.\n\n\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        } // Create a new list item.\n\n\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          }; // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    } // @ts-expect-error Patched.\n\n\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n  /**\n   * @type {CompileContext['setData']}\n   * @param [value]\n   */\n\n\n  function setData(key, value) {\n    data[key] = value;\n  }\n  /**\n   * @type {CompileContext['getData']}\n   * @template {string} K\n   * @param {K} key\n   * @returns {CompileData[K]}\n   */\n\n\n  function getData(key) {\n    return data[key];\n  }\n  /**\n   * @param {Point} d\n   * @returns {Point}\n   */\n\n\n  function point(d) {\n    return {\n      line: d.line,\n      column: d.column,\n      offset: d.offset\n    };\n  }\n  /**\n   * @param {(token: Token) => Node} create\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n\n  function opener(create, and) {\n    return open;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n  /** @type {CompileContext['buffer']} */\n\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n  /**\n   * @type {CompileContext['enter']}\n   * @template {Node} N\n   * @this {CompileContext}\n   * @param {N} node\n   * @param {Token} token\n   * @returns {N}\n   */\n\n\n  function enter(node, token) {\n    const parent = this.stack[this.stack.length - 1]; // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n\n    parent.children.push(node);\n    this.stack.push(node);\n    this.tokenStack.push(token); // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    };\n    return node;\n  }\n  /**\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n\n  function closer(and) {\n    return close;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n  /** @type {CompileContext['exit']} */\n\n\n  function exit(token) {\n    const node = this.stack.pop();\n    const open = this.tokenStack.pop();\n\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): it’s not open');\n    } else if (open.type !== token.type) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): a different token (`' + open.type + '`, ' + stringifyPosition({\n        start: open.start,\n        end: open.end\n      }) + ') is open');\n    }\n\n    node.position.end = point(token.end);\n    return node;\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n\n  function resume() {\n    return toString(this.stack.pop());\n  } //\n  // Handlers.\n  //\n\n  /** @type {Handle} */\n\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true);\n  }\n  /** @type {Handle} */\n\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2];\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n      setData('expectingFirstListItemValue');\n    }\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.lang = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodefencedfencemeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return;\n    this.buffer();\n    setData('flowCodeInside', true);\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodefenced() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    setData('flowCodeInside');\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodeindented() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n  /** @type {Handle} */\n\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n  /** @type {Handle} */\n\n\n  function onexitdefinitiontitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1];\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length;\n      node.depth = depth;\n    }\n  }\n  /** @type {Handle} */\n\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true);\n  }\n  /** @type {Handle} */\n\n\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;\n  }\n  /** @type {Handle} */\n\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding');\n  }\n  /** @type {Handle} */\n\n\n  function onenterdata(token) {\n    const parent = this.stack[this.stack.length - 1];\n    /** @type {Node} */\n\n    let tail = parent.children[parent.children.length - 1];\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text(); // @ts-expect-error: we’ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      }; // @ts-expect-error: Assume `parent` accepts `text`.\n\n      parent.children.push(tail);\n    }\n\n    this.stack.push(tail);\n  }\n  /** @type {Handle} */\n\n\n  function onexitdata(token) {\n    const tail = this.stack.pop();\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n  /** @type {Handle} */\n\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]; // If we’re at a hard break, include the line ending in there.\n\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1];\n      tail.position.end = point(token.end);\n      setData('atHardBreak');\n      return;\n    }\n\n    if (!getData('setextHeadingSlurpLineEnding') && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n  /** @type {Handle} */\n\n\n  function onexithardbreak() {\n    setData('atHardBreak', true);\n  }\n  /** @type {Handle} */\n\n\n  function onexithtmlflow() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexithtmltext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitcodetext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitlink() {\n    const context = this.stack[this.stack.length - 1]; // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference'; // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut'; // @ts-expect-error: mutate.\n\n      delete context.url;\n      delete context.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier; // @ts-expect-error: mutate.\n\n      delete context.label;\n    }\n\n    setData('referenceType');\n  }\n  /** @type {Handle} */\n\n\n  function onexitimage() {\n    const context = this.stack[this.stack.length - 1]; // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference'; // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut'; // @ts-expect-error: mutate.\n\n      delete context.url;\n      delete context.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier; // @ts-expect-error: mutate.\n\n      delete context.label;\n    }\n\n    setData('referenceType');\n  }\n  /** @type {Handle} */\n\n\n  function onexitlabeltext(token) {\n    const ancestor = this.stack[this.stack.length - 2];\n    const string = this.sliceSerialize(token);\n    ancestor.label = decodeString(string);\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\n  }\n  /** @type {Handle} */\n\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1];\n    const value = this.resume();\n    const node = this.stack[this.stack.length - 1]; // Assume a reference.\n\n    setData('inReference', true);\n\n    if (node.type === 'link') {\n      // @ts-expect-error: Assume static phrasing content.\n      node.children = fragment.children;\n    } else {\n      node.alt = value;\n    }\n  }\n  /** @type {Handle} */\n\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitresourcetitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n  /** @type {Handle} */\n\n\n  function onexitresource() {\n    setData('inReference');\n  }\n  /** @type {Handle} */\n\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed');\n  }\n  /** @type {Handle} */\n\n\n  function onexitreferencestring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    setData('referenceType', 'full');\n  }\n  /** @type {Handle} */\n\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type);\n  }\n  /** @type {Handle} */\n\n\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token);\n    const type = getData('characterReferenceType');\n    /** @type {string} */\n\n    let value;\n\n    if (type) {\n      value = decodeNumericCharacterReference(data, type === 'characterReferenceMarkerNumeric' ? 10 : 16);\n      setData('characterReferenceType');\n    } else {\n      // @ts-expect-error `decodeEntity` can return false for invalid named\n      // character references, but everything we’ve tokenized is valid.\n      value = decodeEntity(data);\n    }\n\n    const tail = this.stack.pop();\n    tail.value += value;\n    tail.position.end = point(token.end);\n  }\n  /** @type {Handle} */\n\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = this.sliceSerialize(token);\n  }\n  /** @type {Handle} */\n\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n  /** @returns {Code} */\n\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n  /** @returns {InlineCode} */\n\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n  /** @returns {Definition} */\n\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n  /** @returns {Emphasis} */\n\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n  /** @returns {Heading} */\n\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    };\n  }\n  /** @returns {Break} */\n\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n  /** @returns {HTML} */\n\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n  /** @returns {Image} */\n\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n  /** @returns {Link} */\n\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n  /** @returns {Paragraph} */\n\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n  /** @returns {Strong} */\n\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n  /** @returns {Text} */\n\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n  /** @returns {ThematicBreak} */\n\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n/**\n * @param {Extension} combined\n * @param {Array.<Extension|Array.<Extension>>} extensions\n * @returns {Extension}\n */\n\n\nfunction configure(combined, extensions) {\n  let index = -1;\n\n  while (++index < extensions.length) {\n    const value = extensions[index];\n\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n\n  return combined;\n}\n/**\n * @param {Extension} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\n\nfunction extension(combined, extension) {\n  /** @type {string} */\n  let key;\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      const list = key === 'canContainEols' || key === 'transforms';\n      const maybe = own.call(combined, key) ? combined[key] : undefined;\n      /* c8 ignore next */\n\n      const left = maybe || (combined[key] = list ? [] : {});\n      const right = extension[key];\n\n      if (right) {\n        if (list) {\n          // @ts-expect-error: `left` is an array.\n          combined[key] = [...left, ...right];\n        } else {\n          Object.assign(left, right);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/dragos/Ruby-developer/GitHubDev/muse-ant-design-dashboard/node_modules/mdast-util-from-markdown/lib/index.js"],"names":["toString","parse","preprocess","postprocess","decodeNumericCharacterReference","decodeString","normalizeIdentifier","decodeEntity","stringifyPosition","own","hasOwnProperty","fromMarkdown","value","encoding","options","undefined","compiler","document","write","config","configure","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","list","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","mdastExtensions","compile","events","tree","type","children","stack","tokenStack","listStack","context","resume","setData","getData","index","length","push","tail","pop","prepareList","handler","call","Object","assign","sliceSerialize","Error","start","end","position","point","line","column","offset","containerBalance","listSpread","lineIndex","firstBlankLineIndex","atMarker","event","tailIndex","tailEvent","_spread","splice","key","d","create","and","open","token","node","parent","close","ancestor","Number","parseInt","lang","meta","replace","identifier","toLowerCase","title","url","depth","charCodeAt","text","includes","referenceType","string","fragment","alt","ordered","spread","checked","combined","extensions","Array","isArray","extension","maybe","left","right"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,QAAR,QAAuB,sBAAvB;AACA,SAAQC,KAAR,QAAoB,wBAApB;AACA,SAAQC,UAAR,QAAyB,6BAAzB;AACA,SAAQC,WAAR,QAA0B,8BAA1B;AACA,SAAQC,+BAAR,QAA8C,mDAA9C;AACA,SAAQC,YAAR,QAA2B,8BAA3B;AACA,SAAQC,mBAAR,QAAkC,qCAAlC;AACA,SAAQC,YAAR,QAA2B,iCAA3B;AACA,SAAQC,iBAAR,QAAgC,+BAAhC;AACA,MAAMC,GAAG,GAAG,GAAGC,cAAf;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,YAAY;AACvB;AACF;AACA;AACA;AACA;AACA;AACE,UAAUC,KAAV,EAAiBC,QAAjB,EAA2BC,OAA3B,EAAoC;AAClC,MAAI,OAAOD,QAAP,KAAoB,QAAxB,EAAkC;AAChCC,IAAAA,OAAO,GAAGD,QAAV;AACAA,IAAAA,QAAQ,GAAGE,SAAX;AACD;;AAED,SAAOC,QAAQ,CAACF,OAAD,CAAR,CACLX,WAAW,CACTF,KAAK,CAACa,OAAD,CAAL,CAAeG,QAAf,GAA0BC,KAA1B,CAAgChB,UAAU,GAAGU,KAAH,EAAUC,QAAV,EAAoB,IAApB,CAA1C,CADS,CADN,CAAP;AAKD,CAlBI;AAmBP;AACA;AACA;AACA;AACA;;AAEA,SAASG,QAAT,CAAkBF,OAAO,GAAG,EAA5B,EAAgC;AAC9B;AACA;AACA,QAAMK,MAAM,GAAGC,S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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {UnistParent & {type: 'fragment', children: PhrasingContent[]}} Fragment\n */\n\n/**\n * @typedef _CompileDataFields\n * @property {boolean|undefined} expectingFirstListItemValue\n * @property {boolean|undefined} flowCodeInside\n * @property {boolean|undefined} setextHeadingSlurpLineEnding\n * @property {boolean|undefined} atHardBreak\n * @property {'collapsed'|'full'} referenceType\n * @property {boolean|undefined} inReference\n * @property {'characterReferenceMarkerHexadecimal'|'characterReferenceMarkerNumeric'} characterReferenceType\n *\n * @typedef {Record<string, unknown> & Partial<_CompileDataFields>} CompileData\n *\n * @typedef {(tree: Root) => Root|void} Transform\n * @typedef {(this: CompileContext, token: Token) => void} Handle\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n * @typedef {Record<string, Record<string, unknown>|Array.<unknown>> & {canContainEols: Array.<string>, transforms: Array.<Transform>, enter: Handles, exit: Handles}} NormalizedExtension\n * @typedef {Partial<NormalizedExtension>} Extension\n *   An mdast extension changes how markdown tokens are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context\n * @property {Array.<Node | Fragment>} stack\n * @property {Array.<Token>} tokenStack\n * @property {(key: string, value?: unknown) => void} setData\n *   Set data into the key-value store.\n * @property {<K extends string>(key: K) => CompileData[K]} getData\n *   Get data from the key-value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<N extends Node>(this: CompileContext, node: N, token: Token) => N} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {NormalizedExtension} config\n *   Configuration.\n *\n * @typedef {{mdastExtensions?: Array.<Extension|Array.<Extension>>}} FromMarkdownOptions\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n */\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeEntity} from 'parse-entities/decode-entity.js'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n/**\n * @param value Markdown to parse (`string` or `Buffer`).\n * @param [encoding] Character encoding to understand `value` as when it’s a `Buffer` (`string`, default: `'utf8'`).\n * @param [options] Configuration\n */\n\nexport const fromMarkdown =\n  /**\n   * @param {Value} value\n   * @param {Encoding} [encoding]\n   * @param {Options} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n\n    return compiler(options)(\n      postprocess(\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options} [options]\n */\n\nfunction compiler(options = {}) {\n  /** @type {NormalizedExtension} */\n  // @ts-expect-error: our base has all required fields, so the result will too.\n  const config = configure(\n    {\n      transforms: [],\n      canContainEols: [\n        'emphasis',\n        'fragment',\n        'heading',\n        'paragraph',\n        'strong'\n      ],\n      enter: {\n        autolink: opener(link),\n        autolinkProtocol: onenterdata,\n        autolinkEmail: onenterdata,\n        atxHeading: opener(heading),\n        blockQuote: opener(blockQuote),\n        characterEscape: onenterdata,\n        characterReference: onenterdata,\n        codeFenced: opener(codeFlow),\n        codeFencedFenceInfo: buffer,\n        codeFencedFenceMeta: buffer,\n        codeIndented: opener(codeFlow, buffer),\n        codeText: opener(codeText, buffer),\n        codeTextData: onenterdata,\n        data: onenterdata,\n        codeFlowValue: onenterdata,\n        definition: opener(definition),\n        definitionDestinationString: buffer,\n        definitionLabelString: buffer,\n        definitionTitleString: buffer,\n        emphasis: opener(emphasis),\n        hardBreakEscape: opener(hardBreak),\n        hardBreakTrailing: opener(hardBreak),\n        htmlFlow: opener(html, buffer),\n        htmlFlowData: onenterdata,\n        htmlText: opener(html, buffer),\n        htmlTextData: onenterdata,\n        image: opener(image),\n        label: buffer,\n        link: opener(link),\n        listItem: opener(listItem),\n        listItemValue: onenterlistitemvalue,\n        listOrdered: opener(list, onenterlistordered),\n        listUnordered: opener(list),\n        paragraph: opener(paragraph),\n        reference: onenterreference,\n        referenceString: buffer,\n        resourceDestinationString: buffer,\n        resourceTitleString: buffer,\n        setextHeading: opener(heading),\n        strong: opener(strong),\n        thematicBreak: opener(thematicBreak)\n      },\n      exit: {\n        atxHeading: closer(),\n        atxHeadingSequence: onexitatxheadingsequence,\n        autolink: closer(),\n        autolinkEmail: onexitautolinkemail,\n        autolinkProtocol: onexitautolinkprotocol,\n        blockQuote: closer(),\n        characterEscapeValue: onexitdata,\n        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n        characterReferenceValue: onexitcharacterreferencevalue,\n        codeFenced: closer(onexitcodefenced),\n        codeFencedFence: onexitcodefencedfence,\n        codeFencedFenceInfo: onexitcodefencedfenceinfo,\n        codeFencedFenceMeta: onexitcodefencedfencemeta,\n        codeFlowValue: onexitdata,\n        codeIndented: closer(onexitcodeindented),\n        codeText: closer(onexitcodetext),\n        codeTextData: onexitdata,\n        data: onexitdata,\n        definition: closer(),\n        definitionDestinationString: onexitdefinitiondestinationstring,\n        definitionLabelString: onexitdefinitionlabelstring,\n        definitionTitleString: onexitdefinitiontitlestring,\n        emphasis: closer(),\n        hardBreakEscape: closer(onexithardbreak),\n        hardBreakTrailing: closer(onexithardbreak),\n        htmlFlow: closer(onexithtmlflow),\n        htmlFlowData: onexitdata,\n        htmlText: closer(onexithtmltext),\n        htmlTextData: onexitdata,\n        image: closer(onexitimage),\n        label: onexitlabel,\n        labelText: onexitlabeltext,\n        lineEnding: onexitlineending,\n        link: closer(onexitlink),\n        listItem: closer(),\n        listOrdered: closer(),\n        listUnordered: closer(),\n        paragraph: closer(),\n        referenceString: onexitreferencestring,\n        resourceDestinationString: onexitresourcedestinationstring,\n        resourceTitleString: onexitresourcetitlestring,\n        resource: onexitresource,\n        setextHeading: closer(onexitsetextheading),\n        setextHeadingLineSequence: onexitsetextheadinglinesequence,\n        setextHeadingText: onexitsetextheadingtext,\n        strong: closer(),\n        thematicBreak: closer()\n      }\n    },\n    options.mdastExtensions || []\n  )\n  /** @type {CompileData} */\n\n  const data = {}\n  return compile\n  /**\n   * @param {Array.<Event>} events\n   * @returns {Root}\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {CompileContext['stack']} */\n\n    const stack = [tree]\n    /** @type {CompileContext['tokenStack']} */\n\n    const tokenStack = []\n    /** @type {Array.<number>} */\n\n    const listStack = []\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    const context = {\n      stack,\n      tokenStack,\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    let index = -1\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    if (tokenStack.length > 0) {\n      throw new Error(\n        'Cannot close document, a token (`' +\n          tokenStack[tokenStack.length - 1].type +\n          '`, ' +\n          stringifyPosition({\n            start: tokenStack[tokenStack.length - 1].start,\n            end: tokenStack[tokenStack.length - 1].end\n          }) +\n          ') is still open'\n      )\n    } // Figure out `root` position.\n\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n    index = -1\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n\n    return tree\n  }\n  /**\n   * @param {Array.<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token|undefined} */\n\n    let listItem\n    /** @type {number|undefined} */\n\n    let lineIndex\n    /** @type {number|undefined} */\n\n    let firstBlankLineIndex\n    /** @type {boolean|undefined} */\n\n    let atMarker\n\n    while (++index <= length) {\n      const event = events[index]\n\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            // @ts-expect-error Patched.\n            listItem._spread = true\n          } // Fix position.\n\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        } // Create a new list item.\n\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          } // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    } // @ts-expect-error Patched.\n\n    events[start][1]._spread = listSpread\n    return length\n  }\n  /**\n   * @type {CompileContext['setData']}\n   * @param [value]\n   */\n\n  function setData(key, value) {\n    data[key] = value\n  }\n  /**\n   * @type {CompileContext['getData']}\n   * @template {string} K\n   * @param {K} key\n   * @returns {CompileData[K]}\n   */\n\n  function getData(key) {\n    return data[key]\n  }\n  /**\n   * @param {Point} d\n   * @returns {Point}\n   */\n\n  function point(d) {\n    return {\n      line: d.line,\n      column: d.column,\n      offset: d.offset\n    }\n  }\n  /**\n   * @param {(token: Token) => Node} create\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function opener(create, and) {\n    return open\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n  /** @type {CompileContext['buffer']} */\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n  /**\n   * @type {CompileContext['enter']}\n   * @template {Node} N\n   * @this {CompileContext}\n   * @param {N} node\n   * @param {Token} token\n   * @returns {N}\n   */\n\n  function enter(node, token) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push(token) // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n  /**\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function closer(and) {\n    return close\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n  /** @type {CompileContext['exit']} */\n\n  function exit(token) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): it’s not open'\n      )\n    } else if (open.type !== token.type) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): a different token (`' +\n          open.type +\n          '`, ' +\n          stringifyPosition({\n            start: open.start,\n            end: open.end\n          }) +\n          ') is open'\n      )\n    }\n\n    node.position.end = point(token.end)\n    return node\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n  function resume() {\n    return toString(this.stack.pop())\n  } //\n  // Handlers.\n  //\n\n  /** @type {Handle} */\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n  /** @type {Handle} */\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n  /** @type {Handle} */\n\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n  /** @type {Handle} */\n\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n  /** @type {Handle} */\n\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n  /** @type {Handle} */\n\n  function onenterdata(token) {\n    const parent = this.stack[this.stack.length - 1]\n    /** @type {Node} */\n\n    let tail = parent.children[parent.children.length - 1]\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text() // @ts-expect-error: we’ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      } // @ts-expect-error: Assume `parent` accepts `text`.\n\n      parent.children.push(tail)\n    }\n\n    this.stack.push(tail)\n  }\n  /** @type {Handle} */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n  /** @type {Handle} */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n\n    // If we’re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n  /** @type {Handle} */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n  /** @type {Handle} */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexitlink() {\n    const context = this.stack[this.stack.length - 1] // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference' // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut' // @ts-expect-error: mutate.\n\n      delete context.url\n      delete context.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier // @ts-expect-error: mutate.\n\n      delete context.label\n    }\n\n    setData('referenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitimage() {\n    const context = this.stack[this.stack.length - 1] // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference' // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut' // @ts-expect-error: mutate.\n\n      delete context.url\n      delete context.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier // @ts-expect-error: mutate.\n\n      delete context.label\n    }\n\n    setData('referenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitlabeltext(token) {\n    const ancestor = this.stack[this.stack.length - 2]\n    const string = this.sliceSerialize(token)\n    ancestor.label = decodeString(string)\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n  /** @type {Handle} */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1] // Assume a reference.\n\n    setData('inReference', true)\n\n    if (node.type === 'link') {\n      // @ts-expect-error: Assume static phrasing content.\n      node.children = fragment.children\n    } else {\n      node.alt = value\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n  /** @type {Handle} */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n  /** @type {Handle} */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n  /** @type {Handle} */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n  /** @type {Handle} */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n\n    let value\n\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      // @ts-expect-error `decodeEntity` can return false for invalid named\n      // character references, but everything we’ve tokenized is valid.\n      value = decodeEntity(data)\n    }\n\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n  /** @returns {Code} */\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n  /** @returns {InlineCode} */\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n  /** @returns {Definition} */\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n  /** @returns {Emphasis} */\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n  /** @returns {Heading} */\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n  /** @returns {Break} */\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n  /** @returns {HTML} */\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n  /** @returns {Image} */\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n  /** @returns {Link} */\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    }\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n  /** @returns {Paragraph} */\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n  /** @returns {Strong} */\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n  /** @returns {Text} */\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n  /** @returns {ThematicBreak} */\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n/**\n * @param {Extension} combined\n * @param {Array.<Extension|Array.<Extension>>} extensions\n * @returns {Extension}\n */\n\nfunction configure(combined, extensions) {\n  let index = -1\n\n  while (++index < extensions.length) {\n    const value = extensions[index]\n\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n\n  return combined\n}\n/**\n * @param {Extension} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\nfunction extension(combined, extension) {\n  /** @type {string} */\n  let key\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      const list = key === 'canContainEols' || key === 'transforms'\n      const maybe = own.call(combined, key) ? combined[key] : undefined\n      /* c8 ignore next */\n\n      const left = maybe || (combined[key] = list ? [] : {})\n      const right = extension[key]\n\n      if (right) {\n        if (list) {\n          // @ts-expect-error: `left` is an array.\n          combined[key] = [...left, ...right]\n        } else {\n          Object.assign(left, right)\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}